<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bitcoin Melee — Battle</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    h2 { margin-top: 1rem; }
    ul { list-style: none; padding: 0; }
    li { margin: 0.2rem 0; }
    #startBattle { padding: 0.5rem 1rem; font-size: 1rem; margin-top: 1rem; }
    #battleLog { max-height: 420px; overflow-y: auto; margin-top: 1rem; border: 1px solid #ccc; padding: 0.5rem; background:#fff; }
    .hidden { display: none; }
    /* player controls */
    #controls { margin-top: 1rem; border: 1px solid #999; padding: 0.5rem; background: #fafafa; }
    #controls p { margin: 0.2rem 0 0.4rem; }
    .charCtrl { margin: 0.2rem 0; }
    .charCtrl button { margin-left: 0.4rem; }
    .ap { font-weight: bold; }
  </style>
</head>
<body>
  <h1>Battle Arena</h1>

  <div id="teams">
    <h2>Your Team</h2>
    <ul id="userTeam"></ul>
    <h2>Enemy Team</h2>
    <ul id="enemyTeam"></ul>
  </div>

  <button id="startBattle" disabled>Start Battle</button>
  <div id="battleLog"></div>

  <!-- Player action controls -->
  <div id="controls" class="hidden"></div>

<script>
/***** Constants *****/
const ABILITY_COST = 3;
const ATTACK_COST  = 1;
const AP_PER_TURN  = 5;

/***** Helper Functions *****/
const cap = s => (typeof s === 'string' && s.length) ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : '';
const d20 = () => Math.floor(Math.random() * 20) + 1;
const d6  = () => Math.floor(Math.random() * 6) + 1;
const mod = v => Math.floor((v - 10) / 2);

/***** Load JSON *****/
let characters = [], abilities = {};
Promise.all([
  fetch('characters.json').then(r => r.json()),
  fetch('abilities.json').then(r => r.json())
]).then(([c, a]) => {
  characters = c; abilities = a; initTeams();
  document.getElementById('startBattle').disabled = false;
}).catch(err => console.error('Failed to load data', err));

/***** Ability Target Helpers *****/
function abilityTargetFlags(abilityName){
  const eff = abilities[abilityName] || {};
  let ally=false, foe=false, self=false;
  for(const [k,v] of Object.entries(eff)){
    if(v===0) continue;
    if(k.endsWith('_ally')) ally=true;
    else if(k.endsWith('_Foe')) foe=true;
    else if(k.endsWith('_Self')) self=true;
  }
  // default: if no explicit flags treat as foe spell
  if(!ally && !foe && !self) foe=true;
  return {ally, foe, self};
}
function legalAbilityTargets(actor, allies, foes){
  const flags = abilityTargetFlags(actor.ability);
  let list=[];
  if(flags.self) list.push(actor);
  if(flags.ally) list=list.concat(allies.filter(c=>c!==actor));
  if(flags.foe)  list=list.concat(foes);
  return list;
}

/***** Team Init *****/
let userTeamData = [], enemyTeamData = [];
function initTeams(){
  const stored = sessionStorage.getItem('roster');
  if(!stored){ console.error('No roster found'); return; }
  userTeamData = JSON.parse(stored);
  const used = new Set(userTeamData.map(h=>h.Name));
  const pool = characters.filter(c=>!used.has(c.Name));
  shuffle(pool);
  enemyTeamData = pool.slice(0, userTeamData.length);
  renderInitialLists();
}
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}}

/***** Character Class *****/
class Character{
  constructor(rec){
    this.name = rec.Name;
    this.maxHp = rec.Health; this.hp=this.maxHp;
    this.str = rec.Strength; this.dex=rec.Dexterity; this.con=rec.Constitution;
    this.int = rec.Intelligence; this.wis=rec.Wisdom; this.cha=rec.Charisma;
    this.mana = rec.Mana;
    this.ability = rec['Common Ability']||'';
  }
  isAlive(){return this.hp>0;}
  _applyStat(stat,val){
    switch(stat){
      case 'Health': this.hp=Math.min(this.maxHp,Math.max(0,this.hp+val)); break;
      case 'Strength': this.str=Math.max(0,this.str+val); break;
      case 'Dexterity': this.dex=Math.max(0,this.dex+val); break;
      case 'Constitution': this.con=Math.max(0,this.con+val); break;
      case 'Intelligence': this.int=Math.max(0,this.int+val); break;
      case 'Wisdom': this.wis=Math.max(0,this.wis+val); break;
      case 'Charisma': this.cha=Math.max(0,this.cha+val); break;
      case 'Mana': this.mana=Math.max(0,this.mana+val); break;
    }
  }
  applyAbility(allies,foes,target){
    const eff=abilities[this.ability]||{};
    for(const [k,v] of Object.entries(eff)){
      if(v===0) continue;
      const stat=k.split('_')[0];
      if(k.endsWith('_Self')) this._applyStat(stat,v);
      if(k.endsWith('_ally')) allies.forEach(a=>a._applyStat(stat,v));
      if(k.endsWith('_Foe') && target) target._applyStat(stat,v);
    }
  }
  attack(t){
    const atk=d20()+mod(this.str); const ac=10+mod(t.dex);
    if(atk<ac) return {hit:false,dmg:0};
    const dmg=Math.max(1,d6()+mod(this.str));
    t.hp=Math.max(0,t.hp-dmg);
    return{hit:true,dmg};
  }
}
const inst = arr => arr.map(r=>new Character(r));

/***** UI Rendering *****/
function statLine(obj){
  return `HP:${obj.Health??obj.hp}/${obj.Health??obj.maxHp} Str:${obj.Strength??obj.str} Dex:${obj.Dexterity??obj.dex} Con:${obj.Constitution??obj.con} Int:${obj.Intelligence??obj.int} Wis:${obj.Wisdom??obj.wis} Cha:${obj.Charisma??obj.cha} Mana:${obj.Mana??obj.mana}`;
}
function liForRec(r){
  const li=document.createElement('li');
  li.textContent=`${cap(r.Name)} ${statLine(r)} Ability:${cap(r['Common Ability']||'–')}`;
  const ab=r['Common Ability']; if(ab&&abilities[ab]) li.title=abilities[ab].Description;
  return li;
}
function liForChar(c){
  const li=document.createElement('li');
  li.textContent=`${cap(c.name)} ${statLine(c)} Ability:${cap(c.ability||'–')}${!c.isAlive()?' ✝':''}`;
  if(c.ability&&abilities[c.ability]) li.title=abilities[c.ability].Description;
  return li;
}
function renderInitialLists(){
  const ulU=document.getElementById('userTeam'); ulU.innerHTML='';
  userTeamData.forEach(r=>ulU.appendChild(liForRec(r)));
  const ulE=document.getElementById('enemyTeam'); ulE.innerHTML='';
  enemyTeamData.forEach(r=>ulE.appendChild(liForRec(r)));
}
function refreshLists(){
  const ulU=document.getElementById('userTeam'); ulU.innerHTML='';
  playerChars.forEach(c=>ulU.appendChild(liForChar(c)));
  const ulE=document.getElementById('enemyTeam'); ulE.innerHTML='';
  enemyChars.forEach(c=>ulE.appendChild(liForChar(c)));
}

/***** Battle State *****/
let playerChars=[], enemyChars=[];
let playerAP=0, aiAP=0;
let usedPlayer=new Set(), usedAI=new Set();

const logDiv=document.getElementById('battleLog');
function log(msg){const p=document.createElement('p'); p.textContent=msg; logDiv.appendChild(p); logDiv.scrollTop=logDiv.scrollHeight;}

/***** Battle Flow *****/
function startBattle(){
  document.getElementById('startBattle').disabled=true;
  logDiv.innerHTML='';
  playerChars=inst(userTeamData);
  enemyChars=inst(enemyTeamData);
  refreshLists();
  playerTurn=true;
  startPlayerTurn();
}

/******** PLAYER TURN ********/
function startPlayerTurn(){
  if(checkVictory()) return;
  playerAP=AP_PER_TURN; usedPlayer=new Set();
  log('-- Your Turn --');
  renderPlayerControls();
}
function renderPlayerControls(){
  const ctrl=document.getElementById('controls'); ctrl.innerHTML=''; ctrl.classList.remove('hidden');
  const hdr=document.createElement('p'); hdr.innerHTML=`Your turn — <span class="ap">${playerAP}</span> AP left`; ctrl.appendChild(hdr);
  const candidates=playerChars.filter(c=>c.isAlive()&&!usedPlayer.has(c));
  if(!candidates.length||playerAP<ATTACK_COST){endPlayerTurn(); return;}
  candidates.forEach(c=>{
    const row=document.createElement('div'); row.className='charCtrl';
    const label=document.createElement('span'); label.textContent=cap(c.name); row.appendChild(label);
    if(playerAP>=ATTACK_COST){
      const atk=document.createElement('button'); atk.textContent='Attack (1)'; atk.addEventListener('click',()=>chooseTarget(c,'attack')); row.appendChild(atk);
    }
    if(c.ability && playerAP>=ABILITY_COST){
      const ab=document.createElement('button'); ab.textContent=`${cap(c.ability)} (3)`; ab.title=abilities[c.ability]?.Description||''; ab.addEventListener('click',()=>chooseTarget(c,'ability')); row.appendChild(ab);
    }
    ctrl.appendChild(row);
  });
}
function chooseTarget(char,action){
  const cost=action==='attack'?ATTACK_COST:ABILITY_COST;
  if(playerAP<cost){renderPlayerControls(); return;}
  const ctrl=document.getElementById('controls'); ctrl.innerHTML='';
  const prompt=document.createElement('p'); prompt.textContent=`Choose target for ${cap(char.name)}ʼs ${action==='attack'?'attack':cap(char.ability)}:`; ctrl.appendChild(prompt);
  let targets;
  if(action==='attack') targets=enemyChars.filter(c=>c.isAlive());
  else{
    const allies=playerChars.filter(c=>c.isAlive()); const foes=enemyChars.filter(c=>c.isAlive());
    targets=legalAbilityTargets(char,allies,foes);
  }
  targets.forEach(t=>{
    const btn=document.createElement('button'); btn.textContent=`${cap(t.name)} (${t.hp}/${t.maxHp})`; btn.addEventListener('click',()=>performPlayerAction(char,action,t,cost)); ctrl.appendChild(btn);
  });
  const back=document.createElement('button'); back.textContent='Back'; back.style.marginLeft='0.5rem'; back.addEventListener('click',renderPlayerControls); ctrl.appendChild(back);
}
function performPlayerAction(char,action,target,cost){
  if(!char.isAlive()||usedPlayer.has(char)) {renderPlayerControls(); return;}
  if(playerAP<cost){renderPlayerControls(); return;}
  if(action==='attack'){
    const {hit,dmg}=char.attack(target);
    log(hit?`${cap(char.name)} hits ${cap(target.name)} for ${dmg} dmg (${target.hp}/${target.maxHp})`:`${cap(char.name)} misses ${cap(target.name)}`);
  }else{
    log(`${cap(char.name)} uses ${cap(char.ability)} on ${cap(target.name)}`);
    char.applyAbility(playerChars,enemyChars,target);
  }
  refreshLists(); usedPlayer.add(char); playerAP-=cost;
  if(checkVictory()) return;
  if(playerAP>=ATTACK_COST && playerChars.some(c=>c.isAlive()&&!usedPlayer.has(c))) renderPlayerControls(); else endPlayerTurn();
}
function endPlayerTurn(){ document.getElementById('controls').classList.add('hidden'); playerTurn=false; setTimeout(startAiTurn,600); }

/******** AI TURN ********/
function startAiTurn(){ if(checkVictory()) return; aiAP=AP_PER_TURN; usedAI=new Set(); log('-- Enemy Turn --'); aiStep(); }
function aiStep(){
  if(aiAP<ATTACK_COST){playerTurn=true; setTimeout(startPlayerTurn,600); return;}
  const candidates=enemyChars.filter(c=>c.isAlive()&&!usedAI.has(c));
  if(!candidates.length){playerTurn=true; setTimeout(startPlayerTurn,600); return;}
  const actor=candidates[Math.floor(Math.random()*candidates.length)];
  const canAbility=actor.ability && aiAP>=ABILITY_COST;
  const useAbility=canAbility && Math.random()<0.25;
  const action=useAbility?'ability':'attack';
  const cost=action==='attack'?ATTACK_COST:ABILITY_COST;
  let target;
  if(action==='attack'){
    const foes=playerChars.filter(c=>c.isAlive()); target=foes[Math.floor(Math.random()*foes.length)];
    const {hit,dmg}=actor.attack(target);
    log(hit?`${cap(actor.name)} hits ${cap(target.name)} for ${dmg} dmg (${target.hp}/${target.maxHp})`:`${cap(actor.name)} misses ${cap(target.name)}`);
  }else{
    const allies=enemyChars.filter(c=>c.isAlive()); const foes=playerChars.filter(c=>c.isAlive());
    const possible=legalAbilityTargets(actor,allies,foes);
    target=possible[Math.floor(Math.random()*possible.length)];
    log(`${cap(actor.name)} uses ${cap(actor.ability)} on ${cap(target.name)}`);
    actor.applyAbility(enemyChars,playerChars,target);
  }
  refreshLists(); usedAI.add(actor); aiAP-=cost;
  if(checkVictory()) return;
  setTimeout(aiStep,600);
}

/***** Victory Check *****/
function checkVictory(){
  const youAlive=playerChars.some(c=>c.isAlive()); const enemyAlive=enemyChars.some(c=>c.isAlive());
  if(youAlive&&enemyAlive) return false;
  const yc=playerChars.filter(c=>c.isAlive()).length; const ec=enemyChars.filter(c=>c.isAlive()).length;
  log(yc>ec?`You win! (${yc} vs ${ec})`:ec>yc?`Enemy wins! (${ec} vs ${yc})`:'Tie!');
  document.getElementById('startBattle').disabled=false;
  return true;
}

document.getElementById('startBattle').addEventListener('click',startBattle);
</script>
</body>
</html>
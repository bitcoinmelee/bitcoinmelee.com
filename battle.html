<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bitcoin Melee — Battle</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    h2 { margin-top: 1rem; }
    ul { list-style: none; padding: 0; }
    li { margin: 0.2rem 0; }
    #startBattle { padding: 0.5rem 1rem; font-size: 1rem; margin-top: 1rem; }
    #battleLog p { margin: 0.2rem 0; }
  </style>
</head>
<body>
  <h1>Battle Arena</h1>

  <div id="teams">
    <h2>Your Team</h2>
    <ul id="userTeam"></ul>
    <h2>Enemy Team</h2>
    <ul id="enemyTeam"></ul>
  </div>

  <button id="startBattle">Start Battle</button>
  <div id="battleLog"></div>

<script>
/***** Helper Functions *****/
const cap = s => (typeof s === 'string' && s.length) ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : '';
const d20 = () => Math.floor(Math.random() * 20) + 1;
const d6  = () => Math.floor(Math.random() * 6) + 1;
const mod = v => Math.floor((v - 10) / 2);

/***** Load JSON *****/
let characters = [], abilities = {};
Promise.all([
  fetch('characters.json').then(r => r.json()),
  fetch('abilities.json').then(r => r.json())
]).then(([c, a]) => { characters = c; abilities = a; initTeams(); })
  .catch(err => console.error('Failed to load data', err));

let userTeamData = [], enemyTeamData = [];
function initTeams() {
  const stored = sessionStorage.getItem('roster');
  if (!stored) { console.error('No roster found'); return; }
  userTeamData = JSON.parse(stored);
  const ulU = document.getElementById('userTeam');
  userTeamData.forEach(h => { const li = document.createElement('li'); li.textContent = cap(h.Name); ulU.appendChild(li); });

  const used = new Set(userTeamData.map(h => h.Name));
  const pool = characters.filter(c => !used.has(c.Name));
  shuffle(pool);
  enemyTeamData = pool.slice(0, userTeamData.length);
  const ulE = document.getElementById('enemyTeam');
  enemyTeamData.forEach(h => { const li = document.createElement('li'); li.textContent = cap(h.Name); ulE.appendChild(li); });
}
function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } }

/***** Character Class *****/
class Character {
  constructor(name, hp, str, con, dex, ability) {
    this.name = name; this.maxHp = hp; this.hp = hp;
    this.str = str; this.con = con; this.dex = dex; this.ability = ability;
  }
  isAlive() { return this.hp > 0; }
  applyAbility(allies, foes, target) {
    const eff = abilities[this.ability] || {};
    for (const [k, v] of Object.entries(eff)) {
      const stat = k.split('_')[0];
      if (k.endsWith('_Self')) this._applyStat(stat, v);
      if (k.endsWith('_ally')) allies.forEach(a => a._applyStat(stat, v));
      if (k.endsWith('_Foe') && target) target._applyStat(stat, v);
    }
  }
  _applyStat(stat, val) {
    if (stat === 'Health') this.hp = Math.min(this.maxHp, Math.max(0, this.hp + val));
    if (stat === 'Strength') this.str = Math.max(0, this.str + val);
    if (stat === 'Constitution') this.con = Math.max(0, this.con + val);
    if (stat === 'Dexterity') this.dex = Math.max(0, this.dex + val);
  }
  attack(t) {
    const atk = d20() + mod(this.str);
    const ac  = 10 + mod(t.dex);
    if (atk < ac) return { hit: false, dmg: 0 };
    const dmg = Math.max(1, d6() + mod(this.str));
    t.hp = Math.max(0, t.hp - dmg);
    return { hit: true, dmg };
  }
}
const inst = d => d.map(c => new Character(c.Name, c.Health, c.Strength, c.Constitution, c.Dexterity, c['Common Ability'] || ''));

/***** Simulation returning array of rounds (each round = array of strings) *****/
function simulate(teamA, teamB) {
  const rounds = [];
  let r = 1;
  while (teamA.some(c => c.isAlive()) && teamB.some(c => c.isAlive())) {
    const lines = [`-- Round ${r} --`];
    const order = [...teamA, ...teamB].filter(c => c.isAlive()).sort((a, b) => b.dex - a.dex);
    for (const actor of order) {
      if (!actor.isAlive()) continue;
      const allies = teamA.includes(actor) ? teamA.filter(c => c.isAlive()) : teamB.filter(c => c.isAlive());
      const foes   = teamA.includes(actor) ? teamB.filter(c => c.isAlive()) : teamA.filter(c => c.isAlive());
      if (!foes.length) break;
      const target = foes[Math.floor(Math.random() * foes.length)];
      if (Math.random() < 0.25 && actor.ability) {
        lines.push(`${cap(actor.name)} uses ${cap(actor.ability)}!`);
        actor.applyAbility(allies, foes, target);
      }
      const { hit, dmg } = actor.attack(target);
      lines.push(hit ? `${cap(actor.name)} hits ${cap(target.name)} for ${dmg} dmg (${target.hp}/${target.maxHp})`
                     : `${cap(actor.name)} misses ${cap(target.name)}`);
    }
    const survA = teamA.filter(c => c.isAlive()).length;
    const survB = teamB.filter(c => c.isAlive()).length;
    lines.push(`Survivors — You: ${survA}  Enemy: ${survB}`);
    rounds.push(lines);
    r++;
  }
  const final = [];
  const a = teamA.filter(c => c.isAlive()).length, b = teamB.filter(c => c.isAlive()).length;
  final.push(a > b ? `You win! (${a} vs ${b})` : b > a ? `Enemy wins! (${b} vs ${a})` : `Tie! (${a} vs ${b})`);
  rounds.push(final);
  return rounds;
}

/***** Timed Display (10 s per round) *****/
function playRounds(rounds) {
  const log = document.getElementById('battleLog');
  let i = 0;
  function show() {
    log.innerHTML = '';
    rounds[i].forEach(l => { const p = document.createElement('p'); p.textContent = l; log.appendChild(p); });
    i++;
    if (i < rounds.length) setTimeout(show, 10000); else document.getElementById('startBattle').disabled = false;
  }
  show();
}

/***** Button *****/
document.getElementById('startBattle').addEventListener('click', () => {
  const btn = document.getElementById('startBattle'); btn.disabled = true;
  const rounds = simulate(inst(userTeamData), inst(enemyTeamData));
  playRounds(rounds);
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bitcoin Melee — Battle</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    h2 { margin-top: 1rem; }
    ul { list-style: none; padding: 0; }
    li { margin: 0.2rem 0; }
    #startBattle { padding: 0.5rem 1rem; font-size: 1rem; margin-top: 1rem; }
    #battleLog { max-height: 420px; overflow-y: auto; margin-top: 1rem; border: 1px solid #ccc; padding: 0.5rem; background:#fff; }
    .hidden { display: none; }
    /* player controls */
    #controls { margin-top: 1rem; border: 1px solid #999; padding: 0.5rem; background: #fafafa; }
    #controls p { margin: 0.2rem 0 0.4rem; }
    .charCtrl { margin: 0.2rem 0; }
    .charCtrl button { margin-left: 0.4rem; }
    .ap { font-weight: bold; }
  </style>
</head>
<body>
  <h1>Battle Arena</h1>

  <div id="teams">
    <h2>Your Team</h2>
    <ul id="userTeam"></ul>
    <h2>Enemy Team</h2>
    <ul id="enemyTeam"></ul>
  </div>

  <button id="startBattle" disabled>Start Battle</button>
  <div id="battleLog"></div>

  <!-- Player action controls -->
  <div id="controls" class="hidden"></div>

<script>
/***** Constants *****/
const ABILITY_COST = 3;
const ATTACK_COST  = 1;
const AP_PER_TURN  = 5;

/***** Helper Functions *****/
const cap = s => (typeof s === 'string' && s.length) ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : '';
const d20 = () => Math.floor(Math.random() * 20) + 1;
const d6  = () => Math.floor(Math.random() * 6) + 1;
const mod = v => Math.floor((v - 10) / 2);

/***** Load JSON *****/
let characters = [], abilities = {};
Promise.all([
  fetch('characters.json').then(r => r.json()),
  fetch('abilities.json').then(r => r.json())
]).then(([c, a]) => {
  characters = c; abilities = a; initTeams();
  document.getElementById('startBattle').disabled = false; // enable once data loaded
}).catch(err => console.error('Failed to load data', err));

let userTeamData = [], enemyTeamData = [];
function initTeams() {
  const stored = sessionStorage.getItem('roster');
  if (!stored) { console.error('No roster found'); return; }
  userTeamData = JSON.parse(stored);

  const used = new Set(userTeamData.map(h => h.Name));
  const pool = characters.filter(c => !used.has(c.Name));
  shuffle(pool);
  enemyTeamData = pool.slice(0, userTeamData.length);

  renderInitialTeams();
}
function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } }

/***** Character Class *****/
class Character {
  constructor(rec) {
    // supports both snake‑case and spaced field names
    this.name = rec.Name || rec.name;
    this.maxHp = rec.Health || rec.health;
    this.hp    = this.maxHp;
    this.str   = rec.Strength || rec.strength;
    this.con   = rec.Constitution || rec.constitution;
    this.dex   = rec.Dexterity || rec.dexterity;
    this.ability = rec['Common Ability'] || rec.Ability || rec.ability || '';
  }
  isAlive() { return this.hp > 0; }
  applyAbility(allies, foes, target) {
    const eff = abilities[this.ability] || {};
    for (const [k, v] of Object.entries(eff)) {
      const stat = k.split('_')[0];
      if (k.endsWith('_Self')) this._applyStat(stat, v);
      if (k.endsWith('_ally')) allies.forEach(a => a._applyStat(stat, v));
      if (k.endsWith('_Foe')  && target) target._applyStat(stat, v);
    }
  }
  _applyStat(stat, val) {
    if (stat === 'Health')      this.hp  = Math.min(this.maxHp, Math.max(0, this.hp + val));
    if (stat === 'Strength')    this.str = Math.max(0, this.str + val);
    if (stat === 'Constitution')this.con = Math.max(0, this.con + val);
    if (stat === 'Dexterity')   this.dex = Math.max(0, this.dex + val);
  }
  attack(t) {
    const atk = d20() + mod(this.str);
    const ac  = 10 + mod(t.dex);
    if (atk < ac) return { hit: false, dmg: 0 };
    const dmg = Math.max(1, d6() + mod(this.str));
    t.hp = Math.max(0, t.hp - dmg);
    return { hit: true, dmg };
  }
}
const inst = arr => arr.map(r => new Character(r));

/***** Battle State *****/
let playerChars = [], enemyChars = [];
let playerAP = 0, aiAP = 0;
let playerTurn = true;
let usedPlayer = new Set(), usedAI = new Set();

/***** UI Helpers *****/
const logDiv = document.getElementById('battleLog');
function log(msg) {
  const p = document.createElement('p'); p.textContent = msg; logDiv.appendChild(p);
  logDiv.scrollTop = logDiv.scrollHeight;
}
function renderInitialTeams() {
  const ulU = document.getElementById('userTeam');
  userTeamData.forEach(h => ulU.appendChild(liForRec(h)));
  const ulE = document.getElementById('enemyTeam');
  enemyTeamData.forEach(h => ulE.appendChild(liForRec(h)));
}
function liForRec(r) {
  const li = document.createElement('li');
  li.textContent = `${cap(r.Name)} HP:${r.Health} Str:${r.Strength} Con:${r.Constitution} Dex:${r.Dexterity} Ability:${cap(r['Common Ability']||r.Ability||'–')}`;
  return li;
}
function refreshTeamLists() {
  const ulU = document.getElementById('userTeam');
  ulU.innerHTML = '';
  playerChars.forEach(c => ulU.appendChild(liForChar(c)));
  const ulE = document.getElementById('enemyTeam');
  ulE.innerHTML = '';
  enemyChars.forEach(c => ulE.appendChild(liForChar(c)));
}
function liForChar(c) {
  const li = document.createElement('li');
  li.textContent = `${cap(c.name)} (${c.hp}/${c.maxHp}) Str:${c.str} Con:${c.con} Dex:${c.dex} Ability:${cap(c.ability||'–')}${!c.isAlive()?' ✝':''}`;
  return li;
}

/***** Battle Flow *****/
function startBattle() {
  document.getElementById('startBattle').disabled = true;
  logDiv.innerHTML = '';
  playerChars = inst(userTeamData);
  enemyChars  = inst(enemyTeamData);
  refreshTeamLists();
  playerTurn = true;
  startPlayerTurn();
}

/******* Player Turn ******/
function startPlayerTurn() {
  if (checkVictory()) return;
  playerAP = AP_PER_TURN;
  usedPlayer = new Set();
  log('-- Your Turn --');
  renderPlayerControls();
}
function renderPlayerControls() {
  const ctrl = document.getElementById('controls');
  ctrl.innerHTML = '';
  ctrl.classList.remove('hidden');

  const header = document.createElement('p');
  header.innerHTML = `Your turn — <span class="ap">${playerAP}</span> AP left`;
  ctrl.appendChild(header);

  const candidates = playerChars.filter(c => c.isAlive() && !usedPlayer.has(c));
  if (!candidates.length || playerAP < ATTACK_COST) {
    endPlayerTurn();
    return;
  }

  candidates.forEach((c) => {
    const row = document.createElement('div');
    row.className = 'charCtrl';
    const label = document.createElement('span');
    label.textContent = cap(c.name);
    row.appendChild(label);

    if (playerAP >= ATTACK_COST) {
      const atkBtn = document.createElement('button');
      atkBtn.textContent = 'Attack (1)';
      atkBtn.addEventListener('click', () => chooseTarget(c, 'attack'));
      row.appendChild(atkBtn);
    }

    if (c.ability && playerAP >= ABILITY_COST) {
      const abBtn = document.createElement('button');
      abBtn.textContent = `${cap(c.ability)} (3)`;
      abBtn.addEventListener('click', () => chooseTarget(c, 'ability'));
      row.appendChild(abBtn);
    }
    ctrl.appendChild(row);
  });
}
function chooseTarget(char, action) {
  const cost = action === 'attack' ? ATTACK_COST : ABILITY_COST;
  if (playerAP < cost) { renderPlayerControls(); return; }

  const ctrl = document.getElementById('controls');
  ctrl.innerHTML = '';
  const prompt = document.createElement('p');
  prompt.textContent = `Choose target for ${cap(char.name)}ʼs ${action === 'attack' ? 'attack' : cap(char.ability)}:`;
  ctrl.appendChild(prompt);

  const targets = action === 'attack'
    ? enemyChars.filter(c => c.isAlive())
    : [...playerChars.filter(c => c.isAlive()), ...enemyChars.filter(c => c.isAlive())];

  targets.forEach(t => {
    const btn = document.createElement('button');
    btn.textContent = `${cap(t.name)} (${t.hp}/${t.maxHp})`;
    btn.addEventListener('click', () => performPlayerAction(char, action, t, cost));
    ctrl.appendChild(btn);
  });

  const back = document.createElement('button');
  back.textContent = 'Back';
  back.style.marginLeft = '0.5rem';
  back.addEventListener('click', renderPlayerControls);
  ctrl.appendChild(back);
}
function performPlayerAction(char, action, target, cost) {
  if (!char.isAlive() || usedPlayer.has(char)) { renderPlayerControls(); return; }
  if (playerAP < cost) { renderPlayerControls(); return; }

  if (action === 'attack') {
    const { hit, dmg } = char.attack(target);
    log(hit ? `${cap(char.name)} hits ${cap(target.name)} for ${dmg} dmg (${target.hp}/${target.maxHp})`
            : `${cap(char.name)} misses ${cap(target.name)}`);
  } else {
    log(`${cap(char.name)} uses ${cap(char.ability)} on ${cap(target.name)}`);
    char.applyAbility(playerChars, enemyChars, target);
  }
  refreshTeamLists();
  usedPlayer.add(char);
  playerAP -= cost;

  if (checkVictory()) return;
  if (playerAP >= ATTACK_COST && playerChars.some(c => c.isAlive() && !usedPlayer.has(c))) {
    renderPlayerControls();
  } else {
    endPlayerTurn();
  }
}
function endPlayerTurn() {
  document.getElementById('controls').classList.add('hidden');
  playerTurn = false;
  setTimeout(startAiTurn, 600);
}

/******* AI Turn ******/
function startAiTurn() {
  if (checkVictory()) return;
  aiAP = AP_PER_TURN;
  usedAI = new Set();
  log('-- Enemy Turn --');
  aiStep();
}
function aiStep() {
  if (aiAP < ATTACK_COST) {
    playerTurn = true;
    setTimeout(startPlayerTurn, 600);
    return;
  }
  const candidates = enemyChars.filter(c => c.isAlive() && !usedAI.has(c));
  if (!candidates.length) {
    playerTurn = true;
    setTimeout(startPlayerTurn, 600);
    return;
  }
  const actor = candidates[Math.floor(Math.random() * candidates.length)];

  // decide action respecting AP
  const canAbility = actor.ability && aiAP >= ABILITY_COST;
  const useAbility = canAbility && Math.random() < 0.25;
  const action = useAbility ? 'ability' : 'attack';
  const cost   = action === 'attack' ? ATTACK_COST : ABILITY_COST;

  let target;
  if (action === 'attack') {
    const foes = playerChars.filter(c => c.isAlive());
    target = foes[Math.floor(Math.random() * foes.length)];
    const { hit, dmg } = actor.attack(target);
    log(hit ? `${cap(actor.name)} hits ${cap(target.name)} for ${dmg} dmg (${target.hp}/${target.maxHp})`
            : `${cap(actor.name)} misses ${cap(target.name)}`);
  } else {
    const candidatesAll = [...playerChars.filter(c => c.isAlive()), ...enemyChars.filter(c => c.isAlive())];
    target = candidatesAll[Math.floor(Math.random() * candidatesAll.length)];
    log(`${cap(actor.name)} uses ${cap(actor.ability)} on ${cap(target.name)}`);
    actor.applyAbility(enemyChars, playerChars, target);
  }
  refreshTeamLists();
  usedAI.add(actor);
  aiAP -= cost;
  if (checkVictory()) return;
  setTimeout(aiStep, 600);
}

/***** Victory Check *****/
function checkVictory() {
  const youAlive = playerChars.some(c => c.isAlive());
  const enemyAlive = enemyChars.some(c => c.isAlive());
  if (youAlive && enemyAlive) return false;
  const youCount = playerChars.filter(c => c.isAlive()).length;
  const enemyCount = enemyChars.filter(c => c.isAlive()).length;
  log(youCount > enemyCount ? `You win! (${youCount} vs ${enemyCount})` : enemyCount > youCount ? `Enemy wins! (${enemyCount} vs ${youCount})` : 'Tie!');
  document.getElementById('startBattle').disabled = false;
  return true;
}

/***** Event Listener *****/
document.getElementById('startBattle').addEventListener('click', startBattle);
</script>
</body>
</html>

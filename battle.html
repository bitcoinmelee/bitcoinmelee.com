<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BitcoinÂ MeleeÂ â€”Â BattleÂ Arena</title>

  <!-- Fantasy fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link href="https://fonts.googleapis.com/css2?family=Uncial+Antiqua&family=Montserrat:wght@400;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="style.css" />

  <style>
    :root{
      --parchment:#f9f4e8;
      --ink:#2b2a29;
      --user:#216869;
      --enemy:#a11d33;
      --bar:#fff8ef;
      --border:#8c6b42;
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      padding:5.5rem 1rem 6rem; /* leave space for bars */
      font-family:'Montserrat',sans-serif;
      background:var(--parchment);
      color:var(--ink);
    }
    h1{
      font-family:'Uncial Antiqua',cursive;
      font-size:2.2rem;
      margin:0 0 0.8rem;
      text-align:center;
    }

    /* TEAM BARS */
    .teamBarWrap{
      position:fixed;left:0;width:100%;z-index:20;pointer-events:none;
      display:flex;justify-content:center;
      backdrop-filter:blur(2px);
    }
    #enemyBar{top:0;border-bottom:3px double var(--border);background:var(--bar);} 
    #userBar{bottom:0;border-top:3px double var(--border);background:var(--bar);} 

    .teamBar{
      display:flex;gap:1rem;padding:0.45rem 1rem;margin:0;list-style:none;overflow-x:auto;max-width:100%;
    }
    .teamBar li{
      pointer-events:auto;
      display:flex;
      flex-direction:column;
      align-items:center;
      font-size:0.78rem;
      line-height:1.15;
      min-width:120px;
    }
    .teamBar li strong{font-size:0.85rem;}
    .teamBar progress{width:100px;height:8px;margin-bottom:2px;accent-color:var(--user);} 
    #enemyBar progress{accent-color:var(--enemy);} 

    /* MAIN UI */
    #startBattle{display:block;margin:0 auto;padding:0.55rem 1.3rem;font-size:1.05rem;font-family:'Uncial Antiqua',cursive;background:#d1b280;border:2px solid var(--border);border-radius:6px;cursor:pointer;}
    #startBattle:disabled{opacity:0.5;cursor:not-allowed}

    #battleLog{max-height:260px;overflow-y:auto;margin-top:0.9rem;border:2px solid var(--border);padding:0.7rem;background:#fffefa;font-size:0.9rem;}

    #controls{margin-top:1rem;border:2px solid var(--border);background:#fffefa;padding:0.9rem;border-radius:6px;box-shadow:0 1px 4px rgba(0,0,0,0.15);} 
    #controls p{margin:0 0 0.6rem;font-family:'Uncial Antiqua',cursive;}
    .charCtrl{margin:0.45rem 0}
    .charCtrl button{margin-left:0.5rem;padding:0.24rem 0.6rem;border:1px solid #444;border-radius:4px;background:#dfd6c2;font-size:0.83rem;cursor:pointer;}
    .charCtrl button:hover:not(:disabled){background:#cbbfa6}
    .ap{font-weight:bold}
    .hidden{display:none}
  </style>
</head>
<body>
  <h1>BitcoinÂ Melee</h1>

  <!-- Enemy bar top -->
  <div id="enemyBar" class="teamBarWrap"><ul id="enemyTeam" class="teamBar"></ul></div>

  <!-- Battle controls -->
  <button id="startBattle" disabled>CommenceÂ Battle</button>
  <div id="battleLog"></div>
  <div id="controls" class="hidden"></div>

  <!-- Player bar bottom -->
  <div id="userBar" class="teamBarWrap"><ul id="userTeam" class="teamBar"></ul></div>

<script>
/***** CONSTANTS *****/
const ABILITY_COST=3,ATTACK_COST=1,AP_PER_TURN=5;

/***** UTIL *****/
const cap=s=>s? s[0].toUpperCase()+s.slice(1).toLowerCase():'';
const d20=()=>Math.floor(Math.random()*20)+1;
const d6 =()=>Math.floor(Math.random()*6)+1;
const mod=v=>Math.floor((v-10)/2);

/***** DATA LOAD *****/
let characters=[],abilities={};
Promise.all([
  fetch('characters.json').then(r=>r.json()),
  fetch('abilities.json').then(r=>r.json())
]).then(([c,a])=>{characters=c;abilities=a;initTeams();qs('#startBattle').disabled=false;}).catch(console.error);

const qs=id=>document.querySelector(id);

/***** ABILITY TARGET HELPERS *****/
function abilityFlags(name){const e=abilities[name]||{};let al=false,fo=false,se=false;for(const k in e){ if(k.endsWith('_ally'))al=true; else if(k.endsWith('_Foe'))fo=true; else if(k.endsWith('_Self'))se=true; } if(!al&&!fo&&!se)fo=true;return{al,fo,se};}
function legalTargets(actor,allies,foes){const f=abilityFlags(actor.ability);let out=[];if(f.se)out.push(actor);if(f.al)out=out.concat(allies.filter(x=>x!==actor));if(f.fo)out=out.concat(foes);return out;}

/***** TEAMS *****/
let userTeamData=[],enemyTeamData=[];
function initTeams(){const stored=sessionStorage.getItem('roster');if(!stored)return;userTeamData=JSON.parse(stored);const used=new Set(userTeamData.map(h=>h.Name));const pool=characters.filter(c=>!used.has(c.Name));shuffle(pool);enemyTeamData=pool.slice(0,userTeamData.length);renderInitialBars();}
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}}

/***** CHARACTER CLASS *****/
class Character{constructor(r){Object.assign(this,{name:r.Name,maxHp:r.Health,hp:r.Health,str:r.Strength,dex:r.Dexterity,con:r.Constitution,int:r.Intelligence,wis:r.Wisdom,cha:r.Charisma,mana:r.Mana,ability:r['Common Ability']||r.Ability||''});}
  isAlive(){return this.hp>0;}
  _apply(stat,val){switch(stat){case 'Health':this.hp=Math.min(this.maxHp,Math.max(0,this.hp+val));break;case 'Strength':this.str=Math.max(0,this.str+val);break;case 'Dexterity':this.dex=Math.max(0,this.dex+val);break;case 'Constitution':this.con=Math.max(0,this.con+val);break;case 'Mana':this.mana=Math.max(0,this.mana+val);break;}}
  applyAbility(allies,foes,target){const eff=abilities[this.ability]||{};for(const k in eff){const stat=k.split('_')[0];const v=eff[k];if(k.endsWith('_Self'))this._apply(stat,v);if(k.endsWith('_ally'))allies.forEach(a=>a._apply(stat,v));if(k.endsWith('_Foe')&&target)target._apply(stat,v);} }
  attack(t){const atk=d20()+mod(this.str);if(atk<10+mod(t.dex))return{hit:false,dmg:0};const dmg=Math.max(1,d6()+mod(this.str));t.hp=Math.max(0,t.hp-dmg);return{hit:true,dmg};}}
const inst=a=>a.map(x=>new Character(x));

/***** BAR RENDERING *****/
function hpBar(c,team){const p=document.createElement('progress');p.value=c.hp;p.max=c.maxHp;if(team==='enemy')p.classList.add('enemy');return p;}
function statMini(c){return `HP:${c.hp}/${c.maxHp}Â Str:${c.str}Â Dex:${c.dex}`;}
function liForRec(r,team){const li=document.createElement('li');li.innerHTML=`<strong>${cap(r.Name)}</strong><span style="font-size:0.7rem;">Â ${statMini(r)}</span>`;return li;}
function liForChar(c,team){const li=document.createElement('li');li.appendChild(hpBar(c,team));li.innerHTML+=`<strong>${cap(c.name)}</strong><span style="font-size:0.7rem;">Â ${statMini(c)}</span>`;if(!c.isAlive())li.style.opacity=0.4;return li;}
function renderInitialBars(){qs('#userTeam').innerHTML='';qs('#enemyTeam').innerHTML='';userTeamData.forEach(r=>qs('#userTeam').appendChild(liForRec(r,'user')));enemyTeamData.forEach(r=>qs('#enemyTeam').appendChild(liForRec(r,'enemy')));}function refreshBars(){qs('#userTeam').innerHTML='';qs('#enemyTeam').innerHTML='';playerChars.forEach(c=>qs('#userTeam').appendChild(liForChar(c,'user')));enemyChars.forEach(c=>qs('#enemyTeam').appendChild(liForChar(c,'enemy')));}

/***** STATE *****/
let playerChars=[],enemyChars=[],playerAP=0,aiAP=0,usedP=new Set(),usedE=new Set(),playerTurn=true;const logDiv=qs('#battleLog');const btnStart=qs('#startBattle');btnStart.addEventListener('click',startBattle);

/***** LOG *****/
function log(m){const p=document.createElement('p');p.textContent=m;logDiv.appendChild(p);logDiv.scrollTop=logDiv.scrollHeight;}

/***** BATTLE LOOP (same mechanics as before) *****/
function startBattle(){btnStart.disabled=true;logDiv.innerHTML='';playerChars=inst(userTeamData);enemyChars=inst(enemyTeamData);refreshBars();playerTurn=true;playerTurnStart();}

function playerTurnStart(){if(victory())return;playerAP=AP_PER_TURN;usedP.clear();log('â€” Your Turn â€”');renderControls();}
function renderControls(){const ctr=qs('#controls');ctr.innerHTML='';ctr.classList.remove('hidden');const h=document.createElement('p');h.innerHTML=`<span class="ap">${playerAP}</span> AP`;ctr.appendChild(h);const choices=playerChars.filter(c=>c.isAlive()&&!usedP.has(c));if(!choices.length||playerAP<ATTACK_COST){endPlayerTurn();return;}choices.forEach(c=>{const row=document.createElement('div');row.className='charCtrl';row.textContent=cap(c.name);if(playerAP>=ATTACK_COST){const b=document.createElement('button');b.textContent='Atk(1)';b.onclick=()=>chooseTarget(c,'atk');row.appendChild(b);}if(c.ability&&playerAP>=ABILITY_COST){const b=document.createElement('button');b.textContent=`${cap(c.ability)}(3)`;b.onclick=()=>chooseTarget(c,'ab');row.appendChild(b);}ctr.appendChild(row);});}
function chooseTarget(char,type){const cost=type==='atk'?ATTACK_COST:ABILITY_COST;if(playerAP<cost){renderControls();return;}const ctr=qs('#controls');ctr.innerHTML='';const p=document.createElement('p');p.textContent='Choose target:';ctr.appendChild(p);const targets=type==='atk'?enemyChars.filter(c=>c.isAlive()):legalTargets(char,playerChars.filter(c=>c.isAlive()),enemyChars.filter(c=>c.isAlive()));targets.forEach(t=>{const b=document.createElement('button');b.textContent=cap(t.name);b.onclick=()=>doPlayerAction(char,type,t,cost);ctr.appendChild(b);});}
function doPlayerAction(char,type,target,cost){if(!char.isAlive()||usedP.has(char))return; if(type==='atk'){const {hit,dmg}=char.attack(target);log(hit?`${cap(char.name)} hits ${cap(target.name)} (${dmg})`:`${cap(char.name)} misses ${cap(target.name)}`);}else{log(`${cap(char.name)} uses ${cap(char.ability)} on ${cap(target.name)}`);char.applyAbility(playerChars,enemyChars,target);}refreshBars();usedP.add(char);playerAP-=cost;if(victory())return;playerAP>=ATTACK_COST?renderControls():endPlayerTurn();}
function endPlayerTurn(){qs('#controls').classList.add('hidden');playerTurn=false;setTimeout(enemyTurnStart,600);}

function enemyTurnStart(){if(victory())return;aiAP=AP_PER_TURN;usedE.clear();log('â€” Enemy Turn â€”');enemyStep();}
function enemyStep(){if(aiAP<ATTACK_COST){playerTurn=true;setTimeout(playerTurnStart,600);return;}const ch=enemyChars.filter(c=>c.isAlive()&&!usedE.has(c));if(!ch.length){playerTurn=true;setTimeout(playerTurnStart,600);return;}const actor=ch[Math.floor(Math.random()*ch.length)];const canAb=actor.ability&&aiAP>=ABILITY_COST;const useAb=canAb&&Math.random()<0.25;const type=useAb?'ab':'atk';const cost=type==='atk'?ATTACK_COST:ABILITY_COST;let target;if(type==='atk'){const foes=playerChars.filter(c=>c.isAlive());target=foes[Math.floor(Math.random()*foes.length)];const {hit,dmg}=actor.attack(target);log(hit?`${cap(actor.name)} hits ${cap(target.name)} (${dmg})`:`${cap(actor.name)} misses ${cap(target.name)}`);}else{const allies=enemyChars.filter(c=>c.isAlive());const foes=playerChars.filter(c=>c.isAlive());const pool=legalTargets(actor,allies,foes);target=pool[Math.floor(Math.random()*pool.length)];log(`${cap(actor.name)} uses ${cap(actor.ability)} on ${cap(target.name)}`);actor.applyAbility(enemyChars,playerChars,target);}refreshBars();usedE.add(actor);aiAP-=cost;if(victory())return;setTimeout(enemyStep,600);} 

/***** VICTORY *****/
function victory(){const you=playerChars.some(c=>c.isAlive());const foe=enemyChars.some(c=>c.isAlive());if(you&&foe)return false;log(you&&!foe?'ðŸŽ‰ You win!'

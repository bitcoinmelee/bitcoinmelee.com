<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bitcoin Melee — Battle Arena</title>

  <!-- Fantasy fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link href="https://fonts.googleapis.com/css2?family=Uncial+Antiqua&family=Montserrat:wght@400;600&display=swap" rel="stylesheet" />

  <style>
    :root{
      --parchment:#f9f4e8;
      --ink:#2b2a29;
      --user:#216869;
      --enemy:#a11d33;
      --border:#8c6b42;
      --card:#fff8ef;
    }
    *{box-sizing:border-box}

    /* leave space for fixed panes (a little extra so it never overlaps) */
    body{
      margin:0;
      padding:12vh 1rem 12vh;
      font-family:'Montserrat',sans-serif;
      background:var(--parchment);
      color:var(--ink);
    }

    h1{
      font-family:'Uncial Antiqua',cursive;
      font-size:2.2rem;
      margin:0 0 0.8rem;
      text-align:center;
    }

    /* ———————————  TEAM PANES  ——————————— */
    .teamPane{
      position:fixed;
      left:0;
      width:100%;
      background:var(--card);
      backdrop-filter:blur(2px);
      border:3px double var(--border);
      overflow-y:auto;
      z-index:15;
      padding:0.4rem 1rem;
    }
    #enemyPane{top:0;height:10vh;border-bottom-width:5px;}
    #userPane {bottom:0;height:10vh;border-top-width:5px;}

    .teamPane h2{
      margin:0 0 0.3rem;
      font-family:'Uncial Antiqua',cursive;
      font-size:1.15rem;
    }

    .teamList{
      margin:0;
      padding:0;
      list-style:none;
      display:grid;
      grid-template-columns:1fr 1fr;   /* two columns */
      gap:0.4rem 1rem;
      font-size:0.82rem;
    }
    .teamList li{
      display:flex;
      align-items:center;
      gap:0.35rem;
    }
    .teamList progress{
      width:90px;
      height:8px;
      accent-color:var(--user);
    }
    #enemyPane progress{accent-color:var(--enemy);}
    #userTeam li{color:var(--user);}
    #enemyTeam li{color:var(--enemy);}
    .teamList li strong{font-size:0.9rem;}

    /* ———————————  MAIN UI  ——————————— */
    #startBattle{
      display:block;
      margin:0 auto;
      padding:0.55rem 1.3rem;
      font-size:1.05rem;
      font-family:'Uncial Antiqua',cursive;
      background:#d1b280;border:2px solid var(--border);border-radius:6px;
    }
    #startBattle:disabled{opacity:0.5;cursor:not-allowed;}

    #battleLog{
      max-height:260px;
      overflow-y:auto;
      margin-top:1rem;
      border:2px solid var(--border);
      padding:0.7rem;
      background:#fffefa;
      font-size:0.9rem;
    }

    #controls{
      margin-top:1rem;
      border:2px solid var(--border);
      background:#fffefa;
      padding:0.8rem;
      border-radius:6px;
      box-shadow:0 1px 4px rgba(0,0,0,0.15);
    }
    #controls p{margin:0 0 0.5rem;font-family:'Uncial Antiqua',cursive;}
    .charCtrl{margin:0.45rem 0}
    .charCtrl button{
      margin-left:0.5rem;
      padding:0.25rem 0.6rem;
      border:1px solid #444;border-radius:4px;
      background:#dfd6c2;font-size:0.82rem;
    }
    .charCtrl button:hover:not(:disabled){background:#cbbfa6}
    .hidden{display:none}
  </style>
</head>

<body>
  <h1>Bitcoin Melee</h1>

  <!-- Enemy team (top 10 vh) -->
  <div id="enemyPane" class="teamPane">
    <h2>Enemy Team</h2>
    <ul id="enemyTeam" class="teamList"></ul>
  </div>

  <!-- Main battle UI -->
  <button id="startBattle" disabled>Commence Battle</button>
  <div id="battleLog"></div>
  <div id="controls" class="hidden"></div>

  <!-- Your team (bottom 10 vh) -->
  <div id="userPane" class="teamPane">
    <h2>Your Team</h2>
    <ul id="userTeam" class="teamList"></ul>
  </div>

  
<script>
/*────────────────  GAME LOGIC (unchanged)  ────────────────*/
/* constants */
const ABILITY_COST = 3;
const ATTACK_COST  = 1;
const AP_PER_TURN  = 5;

/* helpers */
const cap = s=>s&&s.length?s[0].toUpperCase()+s.slice(1).toLowerCase():'';
const d20=()=>Math.floor(Math.random()*20)+1;
const d6 =()=>Math.floor(Math.random()*6)+1;
const mod=v=>Math.floor((v-10)/2);

/* data load */
let characters=[],abilities={};
Promise.all([
  fetch('characters.json').then(r=>r.json()),
  fetch('abilities.json').then(r=>r.json())
]).then(([c,a])=>{
  characters=c;abilities=a;initTeams();
  document.getElementById('startBattle').disabled=false;
}).catch(console.error);

/* team init */
let userTeamData=[],enemyTeamData=[];
function initTeams(){
  const stored=sessionStorage.getItem('roster');
  if(!stored)return console.error('No roster saved');
  userTeamData=JSON.parse(stored);
  const used=new Set(userTeamData.map(h=>h.Name));
  const pool=characters.filter(x=>!used.has(x.Name));
  shuffle(pool);
  enemyTeamData=pool.slice(0,userTeamData.length);
  renderInitialLists();
}
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}}

/* character class & helpers (unchanged) */
class Character{
  constructor(r){
    Object.assign(this,{
      name:r.Name,maxHp:r.Health,hp:r.Health,str:r.Strength,dex:r.Dexterity,
      con:r.Constitution,int:r.Intelligence,wis:r.Wisdom,cha:r.Charisma,
      mana:r.Mana,ability:r['Common Ability']||r.Ability||''
    });
  }
  isAlive(){return this.hp>0;}
  attack(t){
    const atk=d20()+mod(this.str);
    if(atk<10+mod(t.dex))return{hit:false,dmg:0};
    const dmg=Math.max(1,d6()+mod(this.str));
    t.hp=Math.max(0,t.hp-dmg);
    return{hit:true,dmg};
  }
  _applyStat(stat,val){
    switch(stat){
      case 'Health': this.hp=Math.min(this.maxHp,Math.max(0,this.hp+val)); break;
      case 'Strength': this.str=Math.max(0,this.str+val); break;
      case 'Dexterity': this.dex=Math.max(0,this.dex+val); break;
      case 'Constitution': this.con=Math.max(0,this.con+val); break;
      case 'Mana': this.mana=Math.max(0,this.mana+val); break;
    }
  }
  applyAbility(allies,foes,target){
    const eff=abilities[this.ability]||{};
    for(const k in eff){
      const stat=k.split('_')[0],v=eff[k];
      if(k.endsWith('_Self')) this._applyStat(stat,v);
      if(k.endsWith('_ally')) allies.forEach(a=>a._applyStat(stat,v));
      if(k.endsWith('_Foe') && target) target._applyStat(stat,v);
    }
  }
}
const inst=a=>a.map(r=>new Character(r));

/* ability targeting helpers */
function abilityFlags(name){
  const e=abilities[name]||{};
  let ally=false,foe=false,self=false;
  for(const k in e){
    if(k.endsWith('_ally')) ally=true;
    else if(k.endsWith('_Foe')) foe=true;
    else if(k.endsWith('_Self')) self=true;
  }
  if(!ally&&!foe&&!self) foe=true;
  return {ally,foe,self};
}
function legalTargets(actor,allies,foes){
  const f=abilityFlags(actor.ability);
  let arr=[];
  if(f.self) arr.push(actor);
  if(f.ally) arr=arr.concat(allies.filter(a=>a!==actor));
  if(f.foe)  arr=arr.concat(foes);
  return arr;
}

/* rendering helpers */
function hpBar(c,team){
  const p=document.createElement('progress');
  p.value=c.hp; p.max=c.maxHp;
  if(team==='enemy') p.classList.add('enemy');
  return p;
}
function statMini(c){return`HP:${c.hp}/${c.maxHp} Str:${c.str} Dex:${c.dex}`;}
function liForRec(r,team){
  const li=document.createElement('li');
  li.appendChild(document.createTextNode(cap(r.Name)));
  li.innerHTML+=` ${statMini(r)}`;
  return li;
}
function liForChar(c,team){
  const li=document.createElement('li');
  li.appendChild(hpBar(c,team));
  li.appendChild(document.createTextNode(` ${cap(c.name)} ${statMini(c)}`));
  if(!c.isAlive()) li.style.opacity=0.4;
  return li;
}
function renderInitialLists(){
  const u=document.getElementById('userTeam');
  const e=document.getElementById('enemyTeam');
  u.innerHTML=''; e.innerHTML='';
  userTeamData.forEach(r=>u.appendChild(liForRec(r,'user')));
  enemyTeamData.forEach(r=>e.appendChild(liForRec(r,'enemy')));
}
function refreshLists(){
  const u=document.getElementById('userTeam');
  const e=document.getElementById('enemyTeam');
  u.innerHTML=''; e.innerHTML='';
  playerChars.forEach(c=>u.appendChild(liForChar(c,'user')));
  enemyChars.forEach(c=>e.appendChild(liForChar(c,'enemy')));
}

/* global battle state */
let playerChars=[],enemyChars=[],playerAP=0,aiAP=0,usedP=new Set(),usedE=new Set(),playerTurn=true;
const logDiv=document.getElementById('battleLog');

/* logging */
function log(m){const p=document.createElement('p');p.textContent=m;logDiv.appendChild(p);logDiv.scrollTop=logDiv.scrollHeight;}

/* battle loop */
document.getElementById('startBattle').addEventListener('click',startBattle);
function startBattle(){
  document.getElementById('startBattle').disabled=true;
  logDiv.innerHTML='';
  playerChars=inst(userTeamData);
  enemyChars =inst(enemyTeamData);
  refreshLists();
  playerTurn=true;
  playerTurnStart();
}

/* player turn */
function playerTurnStart(){
  if(checkVictory())return;
  playerAP=AP_PER_TURN; usedP.clear();
  log('— Your Turn —');
  renderControls();
}
function renderControls(){
  const ctr=document.getElementById('controls');
  ctr.innerHTML=''; ctr.classList.remove('hidden');
  ctr.insertAdjacentHTML('afterbegin',`<p><span class=\"ap\">${playerAP}</span> AP</p>`);
  const choices=playerChars.filter(c=>c.isAlive()&&!usedP.has(c));
  if(!choices.length||playerAP<ATTACK_COST){endPlayerTurn();return;}
  choices.forEach(c=>{
    const row=document.createElement('div'); row.className='charCtrl'; row.textContent=cap(c.name);
    if(playerAP>=ATTACK_COST){
      const b=document.createElement('button'); b.textContent='Atk(1)'; b.onclick=()=>chooseTarget(c,'atk'); row.appendChild(b);
    }
    if(c.ability&&playerAP>=ABILITY_COST){
      const b=document.createElement('button'); b.textContent=`${cap(c.ability)}(3)`; b.onclick=()=>chooseTarget(c,'ab'); row.appendChild(b);
    }
    ctr.appendChild(row);
  });
}
function chooseTarget(char,type){
  const cost=type==='atk'?ATTACK_COST:ABILITY_COST;
  if(playerAP<cost){renderControls();return;}
  const ctr=document.getElementById('controls');
  ctr.innerHTML='<p>Choose target:</p>';
  const targets=type==='atk'
    ? enemyChars.filter(c=>c.isAlive())
    : legalTargets(char,playerChars.filter(c=>c.isAlive()),enemyChars.filter(c=>c.isAlive()));
  targets.forEach(t=>{
    const b=document.createElement('button');
    b.textContent=cap(t.name);
    b.onclick=()=>doPlayerAction(char,type,t,cost);
    ctr.appendChild(b);
  });
}
function doPlayerAction(char,type,target,cost){
  if(!char.isAlive()||usedP.has(char))return;
  if(type==='atk'){
    const {hit,dmg}=char.attack(target);
    log(hit?`${cap(char.name)} hits ${cap(target.name)} (${dmg})`
           :`${cap(char.name)} misses ${cap(target.name)}`);
  }else{
    log(`${cap(char.name)} uses ${cap(char.ability)} on ${cap(target.name)}`);
    char.applyAbility(playerChars,enemyChars,target);
  }
  refreshLists();
  usedP.add(char); playerAP-=cost;
  if(checkVictory())return;
  if(playerAP>=ATTACK_COST) renderControls(); else endPlayerTurn();
}
function endPlayerTurn(){document.getElementById('controls').classList.add('hidden'); playerTurn=false; setTimeout(enemyTurnStart,600);}

/* AI turn */
function enemyTurnStart(){if(checkVictory())return; aiAP=AP_PER_TURN; usedE.clear(); log('— Enemy Turn —'); enemyStep();}
function enemyStep(){
  if(aiAP<ATTACK_COST){playerTurn=true;setTimeout(playerTurnStart,600);return;}
  const choices=enemyChars.filter(c=>c.isAlive()&&!usedE.has(c));
  if(!choices.length){playerTurn=true;setTimeout(playerTurnStart,600);return;}
  const actor=choices[Math.floor(Math.random()*choices.length)];
  const canAb=actor.ability&&aiAP>=ABILITY_COST;
  const useAb=canAb&&Math.random()<0.25;
  const type=useAb?'ab':'atk';
  const cost=type==='atk'?ATTACK_COST:ABILITY_COST;
  let tgt;
  if(type==='atk'){
    const foes=playerChars.filter(c=>c.isAlive());
    tgt=foes[Math.floor(Math.random()*foes.length)];
    const {hit,dmg}=actor.attack(tgt);
    log(hit?`${cap(actor.name)} hits ${cap(tgt.name)} (${dmg})`
           :`${cap(actor.name)} misses ${cap(tgt.name)}`);
  }else{
    const legal=legalTargets(actor,enemyChars.filter(c=>c.isAlive()),playerChars.filter(c=>c.isAlive()));
    tgt=legal[Math.floor(Math.random()*legal.length)];
    log(`${cap(actor.name)} uses ${cap(actor.ability)} on ${cap(tgt.name)}`);
    actor.applyAbility(enemyChars,playerChars,tgt);
  }
  refreshLists();
  usedE.add(actor); aiAP-=cost;
  if(checkVictory())return;
  setTimeout(enemyStep,600);
}

/* victory check */
function checkVictory(){
  const youAlive=playerChars.some(c=>c.isAlive());
  const foeAlive=enemyChars.some(c=>c.isAlive());
  if(youAlive&&foeAlive) return false;
  const yc=playerChars.filter(c=>c.isAlive()).length;
  const ec=enemyChars.filter(c=>c.isAlive()).length;
  log(yc>ec?`🎉 You win! (${yc} vs ${ec})`: ec>yc?`☠️ Enemy wins! (${ec} vs ${yc})`:'Tie!');
  document.getElementById('startBattle').disabled=false;
  return true;
}
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bitcoin¬†Melee¬†‚Äî¬†Battle¬†Arena</title>

  <!-- Fantasy fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link href="https://fonts.googleapis.com/css2?family=Uncial+Antiqua&family=Montserrat:wght@400;600&display=swap" rel="stylesheet" />

  <style>
    :root{
      --parchment:#f9f4e8; --ink:#2b2a29;
      --user:#216869;      --enemy:#a11d33;
      --border:#8c6b42;    --card:#fff8ef;
    }
    *{box-sizing:border-box}

    body{
      margin:0;
      padding:12vh 1rem 12vh;   /* leave space for 10¬†vh roster panes */
      font-family:'Montserrat',sans-serif;
      background:var(--parchment);
      color:var(--ink);
    }
    h1{
      font-family:'Uncial Antiqua',cursive;
      font-size:2.2rem;margin:0 0 1rem;text-align:center;
    }

    /* roster panes */
    .teamPane{
      position:fixed;width:100%;left:0;z-index:15;
      background:var(--card);border:3px double var(--border);
      backdrop-filter:blur(2px);overflow-y:auto;
      padding:0.5rem 1rem;
    }
    #enemyPane{top:0;height:10vh;border-bottom-width:5px;}
    #userPane {bottom:0;height:10vh;border-top-width:5px;}

    .teamPane h2{
      margin:0 0 0.3rem;font-family:'Uncial Antiqua',cursive;font-size:1.15rem;
    }
    .teamList{
      list-style:none;margin:0;padding:0;
      display:grid;grid-template-columns:1fr 1fr;
      gap:0.35rem 0.9rem;font-size:0.8rem;
    }
    .teamList li{display:flex;flex-direction:column;line-height:1.1;}
    .rowTop{display:flex;align-items:center;gap:0.35rem;}
    .rowBottom{display:flex;gap:0.6rem;margin-left:calc(90px + 0.35rem);} /* line up under HP bar */
    .teamList progress{width:90px;height:8px;accent-color:var(--user);}
    #enemyPane progress{accent-color:var(--enemy);}
    #userTeam li{color:var(--user);} #enemyTeam li{color:var(--enemy);}
    .ability{font-style:italic;text-decoration:underline dotted;cursor:help;}
    .teamList strong{font-size:0.88rem;}

    /* main UI */
    #startBattle{
      display:block;margin:0 auto;
      padding:0.55rem 1.3rem;font-size:1.05rem;
      font-family:'Uncial Antiqua',cursive;
      background:#d1b280;border:2px solid var(--border);border-radius:6px;
    }
    #startBattle:disabled{opacity:0.5;cursor:not-allowed;}

    #battleLog{
      max-height:260px;overflow-y:auto;margin-top:1rem;
      border:2px solid var(--border);padding:0.7rem;background:#fffefa;font-size:0.9rem;
    }

    #controls{
      margin-top:1rem;border:2px solid var(--border);
      background:#fffefa;padding:0.8rem;border-radius:6px;
      box-shadow:0 1px 4px rgba(0,0,0,0.15);
    }
    #controls p{margin:0 0 0.5rem;font-family:'Uncial Antiqua',cursive;}
    .charCtrl{margin:0.45rem 0}
    .charCtrl button{
      margin-left:0.5rem;padding:0.25rem 0.6rem;
      border:1px solid #444;border-radius:4px;background:#dfd6c2;font-size:0.82rem;cursor:pointer;
    }
    .charCtrl button:hover:not(:disabled){background:#cbbfa6}
    .hidden{display:none}
    .ap{font-weight:bold}
  </style>
</head>

<body>
  <h1>Bitcoin¬†Melee</h1>

  <!-- enemy roster -->
  <div id="enemyPane" class="teamPane">
    <h2>Enemy¬†Team</h2>
    <ul id="enemyTeam" class="teamList"></ul>
  </div>

  <!-- battle UI -->
  <button id="startBattle" disabled>Commence¬†Battle</button>
  <div id="battleLog"></div>
  <div id="controls" class="hidden"></div>

  <!-- player roster -->
  <div id="userPane" class="teamPane">
    <h2>Your¬†Team</h2>
    <ul id="userTeam" class="teamList"></ul>
  </div>

<script>
/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CONSTANTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
const ABILITY_COST=3, ATTACK_COST=1, AP_PER_TURN=5;

/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
const cap=s=>s? s[0].toUpperCase()+s.slice(1).toLowerCase():'';
const d20=()=>Math.floor(Math.random()*20)+1;
const d6 =()=>Math.floor(Math.random()*6)+1;
const mod=v=>Math.floor((v-10)/2);

/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LOAD DATA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
let characters=[],abilities={};
Promise.all([
  fetch('characters.json').then(r=>r.json()),
  fetch('abilities.json').then(r=>r.json())
]).then(([c,a])=>{
  characters=c; abilities=a;
  initTeams();
  startBattle.disabled=false;
}).catch(console.error);

/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ TEAMS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
let userTeamData=[],enemyTeamData=[];
function initTeams(){
  const stored=sessionStorage.getItem('roster');
  if(!stored){console.error('No roster');return;}
  userTeamData=JSON.parse(stored);
  const used=new Set(userTeamData.map(h=>h.Name));
  const pool=characters.filter(x=>!used.has(x.Name));
  shuffle(pool);
  enemyTeamData=pool.slice(0,userTeamData.length);
  renderInitialLists();
}
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}}

/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CHARACTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
class Character{
  constructor(r){
    Object.assign(this,{
      name:r.Name,maxHp:r.Health,hp:r.Health,
      str:r.Strength,dex:r.Dexterity,con:r.Constitution,
      ability:r['Common Ability']||r.Ability||''
    });
  }
  isAlive(){return this.hp>0;}
  attack(t){
    const atk=d20()+mod(this.str);
    if(atk<10+mod(t.dex))return{hit:false,dmg:0};
    const dmg=Math.max(1,d6()+mod(this.str));
    t.hp=Math.max(0,t.hp-dmg);
    return{hit:true,dmg};
  }
  _applyStat(stat,val){
    if(stat==='Health')   this.hp =Math.min(this.maxHp,Math.max(0,this.hp+val));
    if(stat==='Strength') this.str=Math.max(0,this.str+val);
    if(stat==='Dexterity')this.dex=Math.max(0,this.dex+val);
    if(stat==='Constitution')this.con=Math.max(0,this.con+val);
  }
  applyAbility(allies,foes,target){
    const eff=abilities[this.ability]||{};
    for(const k in eff){
      const s=k.split('_')[0],v=eff[k];
      if(k.endsWith('_Self')) this._applyStat(s,v);
      if(k.endsWith('_ally')) allies.forEach(a=>a._applyStat(s,v));
      if(k.endsWith('_Foe') && target) target._applyStat(s,v);
    }
  }
}
const inst=a=>a.map(r=>new Character(r));

/* ability helpers */
function abilityFlags(name){
  const e=abilities[name]||{};
  let ally=false,foe=false,self=false;
  for(const k in e){
    if(k.endsWith('_ally')) ally=true;
    else if(k.endsWith('_Foe')) foe=true;
    else if(k.endsWith('_Self')) self=true;
  }
  if(!ally&&!foe&&!self) foe=true;
  return {ally,foe,self};
}
function legalTargets(actor,allies,foes){
  const f=abilityFlags(actor.ability);
  let arr=[];
  if(f.self) arr.push(actor);
  if(f.ally) arr=arr.concat(allies.filter(x=>x!==actor));
  if(f.foe)  arr=arr.concat(foes);
  return arr;
}

/* diff helper (HP/Str/Dex/Con) */
function diffString(before,after){
  const map=[['hp','HP'],['str','Str'],['dex','Dex'],['con','Con']];
  const parts=[];
  map.forEach(([k,label])=>{
    const d=(after[k]??0)-(before[k]??0);
    if(d!==0) parts.push(`${d>0?'+':''}${d}¬†${label}`);
  });
  return parts.join(', ');
}

/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ rendering ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
function hpBar(c,team){
  const p=document.createElement('progress');
  p.value=c.hp??c.Health; p.max=c.maxHp??c.Health;
  if(team==='enemy') p.classList.add('enemy');
  return p;
}
function fullStats(o){
  const hp=(o.hp??o.Health)+'/'+(o.maxHp??o.Health);
  return `HP:${hp}¬†Str:${o.str??o.Strength}¬†Dex:${o.dex??o.Dexterity}¬†Con:${o.con??o.Constitution}`;
}
function abilitySpan(name){
  const span=document.createElement('span');
  span.className='ability';
  span.textContent=cap(name);
  span.title=(abilities[name]&&abilities[name].Description)||'';
  return span;
}
function liCommon(topObj,team,isLive){
  const li=document.createElement('li');
  const rowT=document.createElement('div'); rowT.className='rowTop';
  rowT.appendChild(hpBar(topObj,team));
  rowT.appendChild(document.createElement('strong')).textContent=` ${cap(topObj.name||topObj.Name)}`;
  li.appendChild(rowT);

  const rowB=document.createElement('div'); rowB.className='rowBottom';
  rowB.textContent=fullStats(topObj)+' ';
  if(topObj.ability){
    rowB.appendChild(abilitySpan(topObj.ability));
  }
  li.appendChild(rowB);
  if(!isLive) li.style.opacity=0.4;
  return li;
}
function renderInitialLists(){
  userTeam.innerHTML=''; enemyTeam.innerHTML='';
  userTeamData.forEach(r=>userTeam.appendChild(liCommon({...r,name:r.Name},'user',true)));
  enemyTeamData.forEach(r=>enemyTeam.appendChild(liCommon({...r,name:r.Name},'enemy',true)));
}
function refreshLists(){
  userTeam.innerHTML=''; enemyTeam.innerHTML='';
  playerChars.forEach(c=>userTeam.appendChild(liCommon(c,'user',c.isAlive())));
  enemyChars.forEach(c=>enemyTeam.appendChild(liCommon(c,'enemy',c.isAlive())));
}

/*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ battle state & loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*/
let playerChars=[],enemyChars=[];
let playerAP=0,aiAP=0;let usedP=new Set(),usedE=new Set();
let playerTurn=true;
const logDiv=document.getElementById('battleLog');
function log(m){const p=document.createElement('p');p.textContent=m;logDiv.appendChild(p);logDiv.scrollTop=logDiv.scrollHeight;}

startBattle.addEventListener('click',()=>{
  startBattle.disabled=true;logDiv.innerHTML='';
  playerChars=inst(userTeamData); enemyChars=inst(enemyTeamData);
  refreshLists(); playerTurn=true; playerTurnStart();
});

/* player turn */
function playerTurnStart(){if(checkVictory())return; playerAP=AP_PER_TURN;usedP.clear();log('‚Äî Your Turn ‚Äî');renderControls();}
function renderControls(){
  controls.innerHTML='';controls.classList.remove('hidden');
  controls.insertAdjacentHTML('afterbegin',`<p><span class=\"ap\">${playerAP}</span> AP</p>`);
  const choices=playerChars.filter(c=>c.isAlive()&&!usedP.has(c));
  if(!choices.length||playerAP<ATTACK_COST){endPlayerTurn();return;}
  choices.forEach(c=>{
    const row=document.createElement('div');row.className='charCtrl';row.textContent=cap(c.name);
    if(playerAP>=ATTACK_COST){
      const b=document.createElement('button');b.textContent='Atk(1)';b.onclick=()=>chooseTarget(c,'atk');row.appendChild(b);
    }
    if(c.ability&&playerAP>=ABILITY_COST){
      const b=document.createElement('button');b.textContent=`${cap(c.ability)}(3)`;b.onclick=()=>chooseTarget(c,'ab');row.appendChild(b);
    }
    controls.appendChild(row);
  });
}
function chooseTarget(char,type){
  const cost=type==='atk'?ATTACK_COST:ABILITY_COST;if(playerAP<cost){renderControls();return;}
  controls.innerHTML='<p>Choose target:</p>';
  const targets=type==='atk'?enemyChars.filter(c=>c.isAlive())
               :legalTargets(char,playerChars.filter(c=>c.isAlive()),enemyChars.filter(c=>c.isAlive()));
  targets.forEach(t=>{
    const b=document.createElement('button');b.textContent=cap(t.name);
    b.onclick=()=>doPlayerAction(char,type,t,cost);controls.appendChild(b);
  });
}
function doPlayerAction(char,type,target,cost){
  if(!char.isAlive()||usedP.has(char))return;
  if(type==='atk'){
    const {hit,dmg}=char.attack(target);
    log(hit?`${cap(char.name)} hits ${cap(target.name)} (-${dmg}¬†HP)`
           :`${cap(char.name)} misses ${cap(target.name)}`);
  }else{
    const before={hp:target.hp,str:target.str,dex:target.dex,con:target.con};
    char.applyAbility(playerChars,enemyChars,target);
    const delta=diffString(before,target);
    log(`${cap(char.name)} uses ${cap(char.ability)} on ${cap(target.name)}${delta?' ('+delta+')':''}`);
  }
  refreshLists();usedP.add(char);playerAP-=cost;
  if(checkVictory())return;
  playerAP>=ATTACK_COST?renderControls():endPlayerTurn();
}
function endPlayerTurn(){controls.classList.add('hidden');playerTurn=false;setTimeout(enemyTurnStart,600);}

/* AI turn */
function enemyTurnStart(){if(checkVictory())return;aiAP=AP_PER_TURN;usedE.clear();log('‚Äî Enemy Turn ‚Äî');enemyStep();}
function enemyStep(){
  if(aiAP<ATTACK_COST){playerTurn=true;setTimeout(playerTurnStart,600);return;}
  const choices=enemyChars.filter(c=>c.isAlive()&&!usedE.has(c));
  if(!choices.length){playerTurn=true;setTimeout(playerTurnStart,600);return;}
  const actor=choices[Math.floor(Math.random()*choices.length)];
  const canAb=actor.ability&&aiAP>=ABILITY_COST;
  const useAb=canAb&&Math.random()<0.25;
  const type=useAb?'ab':'atk';
  const cost=type==='atk'?ATTACK_COST:ABILITY_COST;
  let tgt;
  if(type==='atk'){
    const foes=playerChars.filter(c=>c.isAlive());
    tgt=foes[Math.floor(Math.random()*foes.length)];
    const {hit,dmg}=actor.attack(tgt);
    log(hit?`${cap(actor.name)} hits ${cap(tgt.name)} (-${dmg}¬†HP)`
           :`${cap(actor.name)} misses ${cap(tgt.name)}`);
  }else{
    const pool=legalTargets(actor,enemyChars.filter(c=>c.isAlive()),playerChars.filter(c=>c.isAlive()));
    tgt=pool[Math.floor(Math.random()*pool.length)];
    const before={hp:tgt.hp,str:tgt.str,dex:tgt.dex,con:tgt.con};
    actor.applyAbility(enemyChars,playerChars,tgt);
    const delta=diffString(before,tgt);
    log(`${cap(actor.name)} uses ${cap(actor.ability)} on ${cap(tgt.name)}${delta?' ('+delta+')':''}`);
  }
  refreshLists();usedE.add(actor);aiAP-=cost;
  if(checkVictory())return;setTimeout(enemyStep,600);
}

/* victory */
function checkVictory(){
  const youAlive=playerChars.some(c=>c.isAlive());
  const foeAlive=enemyChars.some(c=>c.isAlive());
  if(youAlive&&foeAlive)return false;
  const yc=playerChars.filter(c=>c.isAlive()).length;
  const ec=enemyChars.filter(c=>c.isAlive()).length;
  log(yc>ec?`üéâ You win! (${yc} vs ${ec})`
      :ec>yc?`‚ò†Ô∏è Enemy wins! (${ec} vs ${yc})`:'Tie!');
  startBattle.disabled=false;
  return true;
}
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BitcoinÂ MeleeÂ â€”Â BattleÂ Arena</title>

  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link href="https://fonts.googleapis.com/css2?family=Uncial+Antiqua&family=Montserrat:wght@400;600&display=swap" rel="stylesheet" />

  <!-- CSS (unchanged, omitted for brevity) -->
  <style>
    /* â€¦ exact same CSS block from previous version â€¦ */
  </style>
</head>

<body>
  <h1>BitcoinÂ Melee</h1>

  <!-- enemy & player rosters, log, controls (same HTML) -->
  <div id="enemyPane" class="teamPane"><h2>EnemyÂ Team</h2><ul id="enemyTeam" class="teamList"></ul></div>
  <button id="startBattle" disabled>CommenceÂ Battle</button>
  <div id="battleLog"></div>
  <div id="controls" class="hidden"></div>
  <div id="userPane" class="teamPane"><h2>YourÂ Team</h2><ul id="userTeam" class="teamList"></ul></div>

<script>
/*â”€â”€ constants & helpers â”€â”€*/
const ABILITY_COST=3,ATTACK_COST=1,AP_PER_TURN=5;
const cap=s=>s? s[0].toUpperCase()+s.slice(1).toLowerCase():'';
const d20=()=>Math.floor(Math.random()*20)+1, d6=()=>Math.floor(Math.random()*6)+1;
const mod=v=>Math.floor((v-10)/2);

/* helper: grab ability field no matter its key */
const getAbility=o=>{
  return (o.ability||o.Ability||o['Common Ability']||o['Common ability']||'').trim();
};

/*â”€â”€ load JSON â”€â”€*/
let characters=[],abilities={};
Promise.all([
  fetch('characters.json').then(r=>r.json()),
  fetch('abilities.json').then(r=>r.json())
]).then(([c,a])=>{characters=c;abilities=a;initTeams();startBattle.disabled=false;})
  .catch(console.error);

/*â”€â”€ team setup (unchanged) â”€â”€*/
let userTeamData=[],enemyTeamData=[];
function initTeams(){
  const stored=sessionStorage.getItem('roster');if(!stored)return;
  userTeamData=JSON.parse(stored);
  const used=new Set(userTeamData.map(h=>h.Name));
  const pool=characters.filter(x=>!used.has(x.Name));
  shuffle(pool);enemyTeamData=pool.slice(0,userTeamData.length);
  renderInitialLists();
}
const shuffle=a=>{for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}};

/*â”€â”€ Character class (ability now uses getAbility) â”€â”€*/
class Character{
  constructor(r){
    Object.assign(this,{
      name:r.Name,maxHp:r.Health,hp:r.Health,
      str:r.Strength,dex:r.Dexterity,con:r.Constitution,
      int:r.Intelligence,wis:r.Wisdom,cha:r.Charisma,mana:r.Mana,
      ability:getAbility(r),cls:r.Class,faction:r.Faction,kingdom:r.Kingdom
    });
  }
  isAlive(){return this.hp>0;}
  attack(t){const atk=d20()+mod(this.str);if(atk<10+mod(t.dex))return{hit:false,dmg:0};const dmg=Math.max(1,d6()+mod(this.str));t.hp=Math.max(0,t.hp-dmg);return{hit:true,dmg};}
  _apply(s,v){if(s==='Health')this.hp=Math.min(this.maxHp,Math.max(0,this.hp+v));
               if(s==='Strength')this.str=Math.max(0,this.str+v);
               if(s==='Dexterity')this.dex=Math.max(0,this.dex+v);
               if(s==='Constitution')this.con=Math.max(0,this.con+v);}
  applyAbility(als,foes,t){const eff=abilities[this.ability]||{};for(const k in eff){const s=k.split('_')[0],v=eff[k];
    if(k.endsWith('_Self'))this._apply(s,v);
    if(k.endsWith('_ally'))als.forEach(a=>a._apply(s,v));
    if(k.endsWith('_Foe')&&t)t._apply(s,v);
  }}
}
const inst=a=>a.map(r=>new Character(r));

/*â”€â”€ ability helpers (unchanged) â”€â”€*/
function abilityFlags(name){const e=abilities[name]||{};let ally=false,foe=false,self=false;
  for(const k in e){if(k.endsWith('_ally'))ally=true;else if(k.endsWith('_Foe'))foe=true;else if(k.endsWith('_Self'))self=true;}
  if(!ally&&!foe&&!self)foe=true;return{ally,foe,self};}
const legalTargets=(act,als,foes)=>{const f=abilityFlags(act.ability);let list=[];if(f.self)list.push(act);if(f.ally)list=list.concat(als.filter(a=>a!==act));if(f.foe)list=list.concat(foes);return list;};

/*â”€â”€ diff helper (unchanged) â”€â”€*/
const diffString=(b,a)=>[['hp','HP'],['str','Str'],['dex','Dex'],['con','Con']].reduce((arr,[k,l])=>{const d=a[k]-b[k];if(d)arr.push(`${d>0?'+':''}${d}Â ${l}`);return arr;},[]).join(', ');

/*â”€â”€ roster rendering (ability via getAbility) â”€â”€*/
const hpBar=(c,t)=>{const p=document.createElement('progress');p.value=c.hp??c.Health;p.max=c.maxHp??c.Health;if(t==='enemy')p.classList.add('enemy');return p;};
const statLine=o=>`HP:${(o.hp??o.Health)}/${o.maxHp??o.Health}Â Str:${o.str??o.Strength}Â Dex:${o.dex??o.Dexterity}Â Con:${o.con??o.Constitution}Â Int:${o.int??o.Intelligence}Â Wis:${o.wis??o.Wisdom}Â Cha:${o.cha??o.Charisma}Â Mana:${o.mana??o.Mana}`;
const abilitySpan=name=>{const s=document.createElement('span');s.className='ability';s.textContent=cap(name);s.title=(abilities[name]&&abilities[name].Description)||'';return s;};
function statsMeta(li,o){
  const st=document.createElement('div');st.className='rowStats';st.textContent=statLine(o);li.appendChild(st);
  const meta=document.createElement('div');meta.className='rowMeta';
  const cls=o.cls||o.Class,fac=o.faction||o.Faction,king=o.kingdom||o.Kingdom,abil=getAbility(o);
  meta.textContent=`${cls}, ${fac}, ${king}`;
  abil?meta.append(' â€” ',abilitySpan(abil)):meta.append(' â€”');
  li.appendChild(meta);
}
const rowFrom=(o,t,live)=>{const li=document.createElement('li');const top=document.createElement('div');top.className='rowTop';
  top.appendChild(hpBar(o,t));top.appendChild(document.createElement('strong')).textContent=` ${cap(o.name||o.Name)}`;li.appendChild(top);
  statsMeta(li,o);if(!live)li.style.opacity=0.4;return li;};
function renderInitialLists(){userTeam.innerHTML='';enemyTeam.innerHTML='';
  userTeamData.forEach(r=>userTeam.appendChild(rowFrom(r,'user',true)));
  enemyTeamData.forEach(r=>enemyTeam.appendChild(rowFrom(r,'enemy',true)));}
function refreshLists(){userTeam.innerHTML='';enemyTeam.innerHTML='';
  playerChars.forEach(c=>userTeam.appendChild(rowFrom(c,'user',c.isAlive())));
  enemyChars.forEach(c=>enemyTeam.appendChild(rowFrom(c,'enemy',c.isAlive())));}

/*â”€â”€ battle (logic unchanged) â”€â”€*/
let playerChars=[],enemyChars=[],playerAP=0,aiAP=0,usedP=new Set(),usedE=new Set();
const logDiv=document.getElementById('battleLog'),log=m=>{const p=document.createElement('p');p.textContent=m;logDiv.appendChild(p);logDiv.scrollTop=logDiv.scrollHeight;};

startBattle.addEventListener('click',()=>{startBattle.disabled=true;logDiv.innerHTML='';
  playerChars=inst(userTeamData);enemyChars=inst(enemyTeamData);refreshLists();playerAP=AP_PER_TURN;usedP.clear();playerTurn();});

function playerTurn(){if(checkVictory())return;log('â€” Your Turn â€”');controls.classList.remove('hidden');showControls();}
function showControls(){
  controls.innerHTML=`<p><span class="ap">${playerAP}</span> AP</p>`;
  const avail=playerChars.filter(c=>c.isAlive()&&!usedP.has(c));
  if(!avail.length||playerAP<ATTACK_COST){endPlayer();return;}
  avail.forEach(c=>{
    const row=document.createElement('div');row.className='charCtrl';row.textContent=cap(c.name);
    if(playerAP>=ATTACK_COST){const b=document.createElement('button');b.textContent='Atk(1)';b.onclick=()=>pickTarget(c,'atk');row.appendChild(b);}
    if(c.ability&&playerAP>=ABILITY_COST){const b=document.createElement('button');b.textContent=`${cap(c.ability)}(3)`;b.onclick=()=>pickTarget(c,'ab');row.appendChild(b);}
    controls.appendChild(row);
  });
}
function pickTarget(char,type){
  controls.innerHTML='<p>Choose target:</p>';
  const tgts=type==='atk'?enemyChars.filter(c=>c.isAlive()):legalTargets(char,playerChars.filter(c=>c.isAlive()),enemyChars.filter(c=>c.isAlive()));
  tgts.forEach(t=>{const b=document.createElement('button');b.textContent=cap(t.name);b.onclick=()=>actPlayer(char,type,t);controls.appendChild(b);});
}
function actPlayer(char,type,target){
  const cost=type==='atk'?ATTACK_COST:ABILITY_COST;if(playerAP<cost)return;
  if(type==='atk'){const {hit,dmg}=char.attack(target);log(hit?`${cap(char.name)} hits ${cap(target.name)} (-${dmg}Â HP)`:`${cap(char.name)} misses ${cap(target.name)}`);}
  else{const b={hp:target.hp,str:target.str,dex:target.dex,con:target.con};char.applyAbility(playerChars,enemyChars,target);const d=diffString(b,target);log(`${cap(char.name)} uses ${cap(char.ability)} on ${cap(target.name)}${d?' ('+d+')':''}`);}
  refreshLists();usedP.add(char);playerAP-=cost;if(checkVictory())return;playerAP>=ATTACK_COST?showControls():endPlayer();}
function endPlayer(){controls.classList.add('hidden');setTimeout(aiTurn,600);}

function aiTurn(){if(checkVictory())return;aiAP=AP_PER_TURN;usedE.clear();log('â€” Enemy Turn â€”');aiStep();}
function aiStep(){
  if(aiAP<ATTACK_COST){setTimeout(()=>{playerAP=AP_PER_TURN;usedP.clear();playerTurn();},600);return;}
  const choices=enemyChars.filter(c=>c.isAlive()&&!usedE.has(c));if(!choices.length)return aiStep();
  const actor=choices[Math.floor(Math.random()*choices.length)],useAb=actor.ability&&aiAP>=ABILITY_COST&&Math.random()<0.25,type=useAb?'ab':'atk',cost=type==='atk'?ATTACK_COST:ABILITY_COST;
  let target;
  if(type==='atk'){const f=playerChars.filter(c=>c.isAlive());target=f[Math.floor(Math.random()*f.length)];const {hit,dmg}=actor.attack(target);log(hit?`${cap(actor.name)} hits ${cap(target.name)} (-${dmg}Â HP)`:`${cap(actor.name)} misses ${cap(target.name)}`);}
  else{const pool=legalTargets(actor,enemyChars.filter(c=>c.isAlive()),playerChars.filter(c=>c.isAlive()));target=pool[Math.floor(Math.random()*pool.length)];const b={hp:target.hp,str:target.str,dex:target.dex,con:target.con};actor.applyAbility(enemyChars,playerChars,target);const d=diffString(b,target);log(`${cap(actor.name)} uses ${cap(actor.ability)} on ${cap(target.name)}${d?' ('+d+')':''}`);}
  refreshLists();usedE.add(actor);aiAP-=cost;if(checkVictory())return;setTimeout(aiStep,600);
}

function checkVictory(){
  const you=playerChars.some(c=>c.isAlive()),foe=enemyChars.some(c=>c.isAlive());
  if(you&&foe)return false;log(you?`ğŸ‰ You win!`:`â˜ ï¸ Enemy wins!`);startBattle.disabled=false;return true;
}
</script>
</body>
</html>
